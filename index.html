<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webgl</title>
</head>
<body>
    <canvas id="canvas" style="border: solid"> </canvas>
    <div>
        <span>
            FPS: <span id="fps"></span>
        </span>
    </div>
    <script>
        class Circles {
            /**
             * @param {WebGLRenderingContext} gl
             * @param {Array.< Array.<{x: Number, y: Number, r: Number, vx: Number, vy: Number}> >} circlesParams
             */
            constructor(gl, circlesParams, trianglesInsideCircle = 16) {
                this.gl = gl;
                this.circlesParams = circlesParams;
                this.trianglesInsideCircle = trianglesInsideCircle;

                this.triangleBasePoints = 2; // 2 triangle vertices connected to 1 point
                this.triangleVertexComponents = 2; // [x, y]

                this.velocityComponents = 2; // [x, y]

                this.circlePointQuantity = null;
                this.totalPointQuantity = null;
                this.verticesFloatArray = null;
                this.velocitiesFloatArray = null;

                this.init();
            }

            get circlesQuantity() {
                return this.circlesParams.length;
            }
            // /**
            //  * @param {Array.< Array.<{x: Number, y: Number, r: Number}> >} circlesParams
            //  */
            // updateCirclesParams(circlesParams) {
            //     this.circlesParams = circlesParams;

            //     return this;
            // }

            init() {
                if (!this.circlesParams.length) {
                    throw new Error('Circles params are not set');
                }

                this.circlePointQuantity = this.trianglesInsideCircle * this.triangleBasePoints * this.triangleVertexComponents + this.triangleVertexComponents;
                this.totalPointQuantity = this.circlePointQuantity * this.circlesParams.length;

                this.verticesFloatArray = new Float32Array(this.totalPointQuantity);

                this.velocitiesFloatArray = new Float32Array(this.circlesParams.length * this.velocityComponents);  

                this.setVertices();
                this.setVelocities();
            }

            setVelocities() {
                for (let i = 0; i < this.circlesParams.length; i++) {
                    const { vx, vy } = this.circlesParams[i];

                    this.velocitiesFloatArray[i * this.velocityComponents] = vx;
                    this.velocitiesFloatArray[i * this.velocityComponents + 1] = vy;
                }
            }

            // updateTrianglesInsideCircle(trianglesInsideCircle) {
            //     this.trianglesInsideCircle = trianglesInsideCircle;

            //     this.initVerticesFloatArray();
            //     this.setVertices();

            //     return this;
            // }

            setVertices() {
                const { 
                    triangleBasePoints, 
                    trianglesInsideCircle, 
                    triangleVertexComponents: tvc 
                } = this; // 2 triangle vertices connected to 1 point
                
                const step = (Math.PI * 2) / trianglesInsideCircle;

                for (let circleI = 0; circleI < this.circlesParams.length; circleI++) {
                    const circleOffset = circleI * this.circlePointQuantity;
                    const { x, y, r } = this.circlesParams[circleI];
                    
                    this.verticesFloatArray[circleOffset] = x;
                    this.verticesFloatArray[circleOffset + 1] = y;

                    for (let i = 0; i < Math.PI * 2; i += step) {
                        const point2Index = Math.floor((i / step) + step/2) * (triangleBasePoints * tvc) + tvc + circleOffset;
                        const point3Index = point2Index + tvc;
               
                        this.verticesFloatArray[point2Index] = x + Math.cos(i) * r;
                        this.verticesFloatArray[point2Index + 1] = y + Math.sin(i) * r;

                        this.verticesFloatArray[point3Index] = x + Math.cos(i + step) * r;
                        this.verticesFloatArray[point3Index + 1] = y + Math.sin(i + step) * r;
                    }
                }

                console.log(this.verticesFloatArray)

                return this;
            }
        
            getCircleVerticesQuantity() {
                return this.circlePointQuantity / this.triangleVertexComponents;
            }

            move() {
                for (let i = 0; i < this.circlesQuantity; i++) {
                    const { vx, vy, r } = this.circlesParams[i];

                    const startPointIndex = i * this.circlePointQuantity; // center point (hub)

                    for (let j = startPointIndex; j < (i + 1) * this.circlePointQuantity; j+= this.triangleVertexComponents) {
                        this.verticesFloatArray[j] += vx;
                        this.verticesFloatArray[j + 1] += vy;
                    }

                    if (this.verticesFloatArray[startPointIndex] + r > canvas.width || this.verticesFloatArray[startPointIndex] - r < 0) {
                        this.circlesParams[i].vx *= -1;
                    }

                    if (this.verticesFloatArray[startPointIndex + 1] + r > canvas.height || this.verticesFloatArray[startPointIndex + 1] - r < 0) {
                        this.circlesParams[i].vy *= -1;
                    }
                }
            }

            draw() {
                const circleVerticesQuantity = circles.getCircleVerticesQuantity();

                for (let offset = 0; offset < circles.totalPointQuantity; offset += circleVerticesQuantity) {
                    this.gl.drawArrays(gl.TRIANGLE_FAN, offset, circleVerticesQuantity);
                }
            }
        }

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas');
        canvas.width = 900;
        canvas.height = 900;
    
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('webgl not supported');
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type); // создание шейдера

            gl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код
            gl.compileShader(shader); 
            // компилируем шейдер

            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {                        // если компиляция прошла успешно - возвращаем шейдер
                return shader;
            }
            
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();

            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.linkProgram(program);

            const success = gl.getProgramParameter(program, gl.LINK_STATUS);

            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const variables = {
            position: 'a_position',
            // shapeLocation: 'u_offset',
            color: 'u_color',
            canvasSize: 'canvasSize',
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, 
        `
            precision mediump float;

            // атрибут, который будет получать данные из !!буфера
            attribute vec2 ${variables.position};

            uniform vec2 ${variables.canvasSize};
            uniform vec2 ${variables.shapeLocation};

            vec2 posToClipSpace(vec2 position) {
                return (position / ${variables.canvasSize}) * 2.0 - 1.0;
            }
            
            // все шейдеры имеют функцию main
            void main() {
                vec2 clipPosition = posToClipSpace(${variables.position});

                // gl_Position - специальная переменная вершинного шейдера,
                // которая отвечает за установку положения
                gl_Position = vec4(clipPosition, 0, 1);
            }
        `
        );
        
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, 
        `
            // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам необходимо её
            precision mediump float;
            uniform vec3 ${variables.color};

            void main() {
                // gl_FragColor - специальная переменная фрагментного шейдера.
                // Она отвечает за установку цвета.
                gl_FragColor = vec4(${variables.color}, 1);
            }
        `
        );
        
        const program = createProgram(gl, vertexShader, fragmentShader);

        
        gl.useProgram(program);


        // gl.clearColor(0, 0, 0, 0);
        // gl.clear(gl.COLOR_BUFFER_BIT);

        
        
        const locations = {
            // offset: gl.getUniformLocation(program, variables.shapeLocation),
            color: gl.getUniformLocation(program, variables.color),
            position: gl.getAttribLocation(program, variables.position),
            canvasSize: gl.getUniformLocation(program, variables.canvasSize),
        };

        // global variables
        gl.uniform2f(locations.canvasSize, canvas.width, canvas.height);
        gl.uniform3f(locations.color, Math.random(), Math.random(), Math.random());


        const circles = new Circles(gl, Array(1000).fill(0).map(() => {
            const r = Math.random() * 5 + 4;

            return {
                x: Math.random() * (canvas.width - r * 2) + r,
                y: Math.random() * (canvas.height - r * 2) + r,
                r,
                vx: Math.random() * 2 - 1,
                vy: Math.random() * 2 - 1,
            }
        }), 30);

        // circles.setVertices();



        // Привязываем буфер положений
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // передаём в буфер вершины
        gl.bufferData(gl.ARRAY_BUFFER, circles.verticesFloatArray, gl.STATIC_DRAW);


        //  buffer -> attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(locations.position);
        gl.vertexAttribPointer(
            locations.position, 
            2, 
            gl.FLOAT, 
            false, 
            2 * Float32Array.BYTES_PER_ELEMENT, 
            0
        );


        /*
            
            // Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
            const size = 2;          // 2 компоненты на итерацию
            const type = gl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой
            const normalize = false; 
            const stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
            const offset = 0;        // начинать с начала буфера
            gl.vertexAttribPointer(
                // index: which attr to use  
                locations.position, 
                // size: how many components in that attr 
                size, 
                // type: what is the type stored in the GPU buffer for this attr 
                type, 
                // normalize: determines how to convert ints to float (convert from 0-255 to 0-1) 
                normalize, 
                // stride: how many bytes to move forward to get the same attr for the next vertex 
                2 * Float32Array.BYTES_PER_ELEMENT, // if 0 = size * sizeof(type)
                // offset: how many bytes skip when reading attrs 
                offset
            );

        */

        gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        circles.draw();

        // const drawCircles = () => {
        //     const circleVerticesQuantity = circles.getCircleVerticesQuantity();

        //     for (let i = 0; i < circles.circlesQuantity; i++) {
        //         gl.drawArrays(gl.TRIANGLE_FAN, i * circleVerticesQuantity, circleVerticesQuantity);
        //     }
        // }

        // drawCircles();

        let prefMs = 0;

        const frame = (time) => {
            if (Math.trunc(time) % 4 === 0) {
                fps.innerText = (1000 / (time - prefMs)).toFixed(2);
            }

            gl.clearColor(5 / 255, 25 / 255, 55 / 255, 0.99);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            circles.move();

            gl.bufferData(gl.ARRAY_BUFFER, circles.verticesFloatArray, gl.STATIC_DRAW);

            circles.draw();

            prefMs = time
            requestAnimationFrame(frame);
        }

        frame();


        // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, positionBuffer);
        // gl.drawElements(
        //     gl.TRIANGLE_FAN,
        //     17,
        //     gl.UNSIGNED_SHORT,
        //     0
        // );



    </script>
</body>
</html>