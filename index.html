<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webgl</title>
</head>
<body>
    <canvas id="canvas" style="border: solid"> </canvas>
    <div>
        <span>
            FPS: <span id="fps"></span>
        </span>
        <span>
            Amount of vertex: <span id="shadersCount"></span>
        </span>
    </div>
    <script>
        const options = {}

        /**
         * @deprecated 
         */
        class Circles {
            /**
             * @param {WebGLRenderingContext} gl
             * @param {Array.< Array.<{x: Number, y: Number, r: Number, vx: Number, vy: Number}> >} circlesParams
             */
            constructor(gl, trianglesInsideCircle = 16) {
                this.gl = gl;
                this.trianglesInsideCircle = trianglesInsideCircle;

                this.vertexComponents = 2; // [x, y]
                this.triangleBasePoints = 2; // [x1, y1] [x2, y2] 2 triangle vertices connected to 1 point [x0, y0]

                // points for 1 circle
                this.circlePointQuantity = this.trianglesInsideCircle * this.triangleBasePoints * this.vertexComponents + this.vertexComponents;

                this.vertices = new Float32Array(0);
                this.velocities = new Float32Array(0);
                this.accelerations = new Float32Array(0);
            }

            get circlesQuantity() {
                return this.vertices.length / this.circlePointQuantity;
            }

            get circleVerticesQuantity() {
                return this.circlePointQuantity / this.vertexComponents;
            }

            expandArray(length, array) {
                const newArray = new Float32Array(
                    length * this.vertexComponents + array.length
                );

                newArray.set(array);

                return newArray;
            }

            /**
             * @param {Array.< Array.<{avx: Number, avy: Number}> >} params
             */
            addAccelerations(params) {
                const fillFrom = this.accelerations.length;

                this.accelerations = this.expandArray(params.length, this.accelerations);

                for (let i = 0; i < params.length; i++) {
                    const { avx, avy } = params[i];

                    // [x => i*2 + 0]...
                    this.accelerations[i * this.vertexComponents + fillFrom] = avx;
                    // [y => i*2 + 1]...
                    this.accelerations[i * this.vertexComponents + 1 + fillFrom] = avy;
                }

                console.log(this.accelerations);

                return this;
            }

            

            /** 
             * @param {Array.< Array.<{vx: Number, vy: Number >} params
             */
            addVelocities(params) {
                const fillFrom = this.velocities.length;

                this.velocities = this.expandArray(params.length, this.velocities);

                for (let i = 0; i < params.length; i++) {
                    const { vx, vy } = params[i];

                    // [x => i*2 + 0]...
                    this.velocities[i * this.vertexComponents + fillFrom] = vx;
                    // [y => i*2 + 1]...
                    this.velocities[i * this.vertexComponents + 1 + fillFrom] = vy;
                }

                console.log(this.velocities);

                return this;
            }

             /**
             *  @param {Array.<{x: Number, y: Number, r: Number >} params
             */
            addCirclesVertices(params) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(params.length, this.vertices);

                const { 
                    triangleBasePoints, 
                    trianglesInsideCircle, 
                    vertexComponents 
                } = this; // 2 triangle vertices connected to 1 point
                
                const step = (Math.PI * 2) / trianglesInsideCircle;

                for (let circleI = 0; circleI < params.length; circleI++) {
                    const circleOffset = circleI * this.circlePointQuantity + fillFrom;
                    const { x, y, r } = params[circleI];
                    
                    // center point (hub) [x0, y0], the point in which all triangle's bases connected
                    this.vertices[circleOffset] = x;
                    this.vertices[circleOffset + 1] = y;

                    // connected points [x1, y1, x2, y2, ...] to hub
                    for (let i = 0; i < Math.PI * 2; i += step) { // TODO:change this for by maxCount points
                        // ( (i / step) - index of current triangle = 
                        // ==> + step/2 ) - adding small number to prevent floating point errors 
                        // ==> * (triangleBasePoints * vertexComponents) - for each iter. skip triangle = ,[x1, y1] [x2, y2],
                        // ==> + vertexComponents - skip first hub point
                        // ==> + circleOffset - skip existing circles

                        const point2Index = Math.floor((i / step) + step/2) * (triangleBasePoints * vertexComponents) + vertexComponents + circleOffset;
                        const point3Index = point2Index + vertexComponents;
               
                        this.vertices[point2Index] = x + Math.cos(i) * r;
                        this.vertices[point2Index + 1] = y + Math.sin(i) * r;

                        this.vertices[point3Index] = x + Math.cos(i + step) * r;
                        this.vertices[point3Index + 1] = y + Math.sin(i + step) * r;
                    }
                }

                console.log(this.vertices)

                return this;
            }

            move() {
                for (let i = 0; i < this.velocities.length; i+= this.vertexComponents) {
                    const vx = this.velocities[i];
                    const vy = this.velocities[i + 1];

                    const avx = this.accelerations[i];
                    const avy = this.accelerations[i + 1];

                    this.velocities[i] += avx;
                    this.velocities[i + 1] += avy;

                    // this.velocities[i] /= 1.1;
                    // this.velocities[i + 1] /= 1.1;

                    // if (Math.random() > 0.9) {
                    //     this.velocities[i] /= 1.1;
                    //     this.velocities[i + 1] /= 1.1;
                    // }

                    // velocity corresponds for multiple points (circle)
                    // i / this.vertexComponents - index of current velocity vector
                    // * this.circlePointQuantity - skip points for each circle
                    const startPointIndex = (i / this.vertexComponents) * this.circlePointQuantity; // center point (hub)

                    // iterate through each circle [fromCircle -> x0, y0, x1, y1, x2, y2, ... toCircle]
                    for (let j = 0; j < this.circlePointQuantity; j+= this.vertexComponents) {
                        this.vertices[j + startPointIndex] += vx;
                        this.vertices[j + startPointIndex + 1] += vy;
                    }

                    // if (this.vertices[startPointIndex] + r + vx > canvas.width || this.vertices[startPointIndex] - r + vx < 0) {
                       
                    // }

                    // if (this.vertices[startPointIndex + 1] + r + vy > canvas.height || this.vertices[startPointIndex + 1] - r + vy < 0) {
                    
                    // }
                }
            }

            // removeLastCircle() {
            //     this.circlesParams.pop();
            //     this.init();
            // }

            draw() {
                for (let offset = 0; offset < this.vertices.length; offset += this.circleVerticesQuantity) {
                    this.gl.drawArrays(gl.TRIANGLE_FAN, offset, this.circleVerticesQuantity);
                }
            }
        }

        // class StaticPoints {}

        class Points {
             /**
             * @param {WebGLRenderingContext} gl
             */
            static VERTEX_COMPONENTS = 2; // [x, y]
            static COLOR_COMPONENTS = 4; // [r, g, b, a]
            constructor(gl) {
                this.gl = gl;

                this.vertices = new Float32Array(0);
                this.velocities = new Float32Array(0);
                this.accelerations = new Float32Array(0);
                this.colors = new Float32Array(0);
            }

            expandArray(length, array, vc = Points.VERTEX_COMPONENTS) {
                const newArray = new Float32Array(
                    length * vc + array.length
                );

                newArray.set(array);

                return newArray;
            }

            addVertices(vertices) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(vertices.length, this.vertices, 1);

                for (let i = 0; i < vertices.length; i++) {
                    this.vertices[i + fillFrom] = vertices[i];
                }

                return this;
            }

            addColors(colors) {
                const fillFrom = this.colors.length;

                this.colors = this.expandArray(colors.length, this.colors, 1);

                for (let i = 0; i < colors.length; i++) {
                    this.colors[i + fillFrom] = colors[i];
                }

                return this;
            }

            /**
             *  @param {Array.<{x: Number, y: Number >} params
             */
            addPointsVertices(params) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(params.length, this.vertices);
                this.colors = this.expandArray(params.length, this.colors, Points.COLOR_COMPONENTS);

                for (let i = 0; i < params.length; i++) {
                    const { x, y, r, g, b, a } = params[i];

                    // [x => i*2 + 0]...
                    this.vertices[i * Points.VERTEX_COMPONENTS + fillFrom] = x;
                    // [y => i*2 + 1]...
                    this.vertices[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = y;

                    this.colors[i * Points.COLOR_COMPONENTS + fillFrom] = r;
                    this.colors[i * Points.COLOR_COMPONENTS + 1 + fillFrom] = g;
                    this.colors[i * Points.COLOR_COMPONENTS + 2 + fillFrom] = b;   
                    this.colors[i * Points.COLOR_COMPONENTS + 3 + fillFrom] = a;
                }

                return this;
            }
            
            /** 
             * @param {Array.< Array.<{vx: Number, vy: Number >} params
             */
            addVelocities(params) {
                const fillFrom = this.velocities.length;

                this.velocities = this.expandArray(params.length, this.velocities);

                for (let i = 0; i < params.length; i++) {
                    const { vx, vy } = params[i];

                    // [x => i*2 + 0]...
                    this.velocities[i * Points.VERTEX_COMPONENTS + fillFrom] = vx;
                    // [y => i*2 + 1]...
                    this.velocities[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = vy;
                }

                return this;
            }
            /**
             * @param {Array.< Array.<{avx: Number, avy: Number}> >} params
             */
            addAccelerations(params) {
                const fillFrom = this.accelerations.length;

                this.accelerations = this.expandArray(params.length, this.accelerations);

                for (let i = 0; i < params.length; i++) {
                    const { avx, avy } = params[i];

                    // [x => i*2 + 0]...
                    this.accelerations[i * Points.VERTEX_COMPONENTS + fillFrom] = avx;
                    // [y => i*2 + 1]...
                    this.accelerations[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = avy;
                }

                return this;
            }

            move() {
                for (let i = 0; i < this.velocities.length; i+= Points.VERTEX_COMPONENTS) {
                    const vx = this.velocities[i];
                    const vy = this.velocities[i + 1];
                    const avx = this.accelerations[i];
                    const avy = this.accelerations[i + 1];

                    //v resistance
                    this.velocities[i] /= 1.1;
                    this.velocities[i + 1] /= 1.1;

                    // a resistance
                    this.accelerations[i] /= 1.1;
                    this.accelerations[i + 1] /= 1.1;

                    this.vertices[i] += vx;
                    this.vertices[i + 1] += vy;

                    this.velocities[i] += avx;  
                    this.velocities[i + 1] += avy;

                    // if (this.vertices[i] + vx > canvas.width || this.vertices[i] + vx < 0) {
                    //     this.velocities[i] *= -1;
                    // }

                    // if (this.vertices[i + 1] + vy > canvas.height || this.vertices[i + 1] + vy < 0) {
                    //     this.velocities[i + 1] *= -1;
                    // }
                }
            }
        }


        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas');
        canvas.width = 900;
        canvas.height = 900;
    
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('webgl not supported');
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type); // создание шейдера

            gl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код
            gl.compileShader(shader); 
            // компилируем шейдер

            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {                        // если компиляция прошла успешно - возвращаем шейдер
                return shader;
            }
            
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();

            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.linkProgram(program);

            const success = gl.getProgramParameter(program, gl.LINK_STATUS);

            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const variables = {
            position: 'a_position',
            color: 'a_color',
            canvasSize: 'canvasSize',
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, 
        `
            precision mediump float;

            // атрибут, который будет получать данные из !!буфера
            attribute vec2 ${variables.position};
            attribute vec4 ${variables.color};

            uniform vec2 ${variables.canvasSize};

            varying vec4 v_color;

            vec2 posToClipSpace(vec2 position) {
                return (position / ${variables.canvasSize}) * 2.0 - 1.0;
            }
            
            // все шейдеры имеют функцию main
            void main() {
                v_color = ${variables.color};

                vec2 clipPosition = posToClipSpace(${variables.position});
                gl_PointSize = 2.0;
                // gl_Position - специальная переменная вершинного шейдера,
                // которая отвечает за установку положения
                gl_Position = vec4(clipPosition, 0, 1);
            }
        `
        );
        
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, 
        `
            // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам необходимо её
            precision mediump float;

            varying vec4 v_color;

            void main() {
                // gl_FragColor - специальная переменная фрагментного шейдера.
                // Она отвечает за установку цвета.
                gl_FragColor = v_color;
            }
        `
        );
        
        const program = createProgram(gl, vertexShader, fragmentShader);

        
        gl.useProgram(program);

        
        const locations = {
            // offset: gl.getUniformLocation(program, variables.shapeLocation),
            position: gl.getAttribLocation(program, variables.position),
            color: gl.getAttribLocation(program, variables.color),
            canvasSize: gl.getUniformLocation(program, variables.canvasSize),
        };

        // global variables
        gl.uniform2f(locations.canvasSize, canvas.width, canvas.height);


        // const circles = new Circles(gl, 4);

        // Привязываем буфер положений
        const positionBuffer = gl.createBuffer();
        const colorsBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // передаём в буфер вершины
        // gl.bufferData(gl.ARRAY_BUFFER, circles.vertices, gl.STATIC_DRAW);


        //  buffer -> attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(locations.position);
        gl.vertexAttribPointer(
            locations.position, 
            2, 
            gl.FLOAT, 
            false, 
            2 * Float32Array.BYTES_PER_ELEMENT, 
            0
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer)
        gl.enableVertexAttribArray(locations.color)
        gl.vertexAttribPointer(
            locations.color, 
            4, 
            gl.FLOAT, 
            false, 
            4 * Float32Array.BYTES_PER_ELEMENT, 
            0
        )


        /*
            
            // Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
            const size = 2;          // 2 компоненты на итерацию
            const type = gl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой
            const normalize = false; 
            const stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
            const offset = 0;        // начинать с начала буфера
            gl.vertexAttribPointer(
                // index: which attr to use  
                locations.position, 
                // size: how many components in that attr 
                size, 
                // type: what is the type stored in the GPU buffer for this attr 
                type, 
                // normalize: determines how to convert ints to float (convert from 0-255 to 0-1) 
                normalize, 
                // stride: how many bytes to move forward to get the same attr for the next vertex 
                2 * Float32Array.BYTES_PER_ELEMENT, // if 0 = size * sizeof(type)
                // offset: how many bytes skip when reading attrs 
                offset
            );

        */

        gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        

        class Shell {
            constructor(x, y, r, g, b, a) {
                this.x = x;
                this.y = y;
                
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;

                this.count = 60;
                this.vMax = 10;

                this.maxTracesSeries = 30;
                this.tracesSeries = 0;

                this.traceSeriesGenerator = this.generateHeads();

                this.heads = new Points(gl);
                this.traces = new Points(gl); // static points
            }

            *generateHeads() {
                const { vMax, x, y, r, g, b, a } = this;

                for (let i = 0; i < this.count; i += 1) {
                    const angle = Math.PI * 2 * i / this.count;

                    const v = {
                        vx:  Math.cos(angle) * vMax * Math.random(), 
                        vy:  Math.sin(angle) * vMax * Math.random(),
                    };

                    const circle = {
                        x: x + Math.cos(angle),
                        y: y + Math.sin(angle),
                        r, g, b, a
                    };
                    
                    const av = {
                        avx: 0,
                        avy: -0.1,
                    };

                    yield { v, circle, av };
                }
            }
        }

        let shell = null;
        let oldVertices = new Float32Array();
        let oldColors = new Float32Array();
        let prevTime = 0;


        const fireworks = [];

        const frame = (time) => {
            if (Math.trunc(time) % 4 === 0) {
                fps.innerText = (1000 / (time - prevTime)).toFixed(2);
            }

            let numOfHeads = 0;
            let numOfTraces = 0;


            gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            for (let i = 0; i < fireworks.length; i++) {

                const shell = fireworks[i];

                const { heads: points, traces } = shell;

                numOfHeads += points.vertices.length;
                numOfTraces += traces.vertices.length;

                const positions = [];
                const velocities = [];
                const accelerations = [];

                for (const trace of shell.traceSeriesGenerator) {
                    positions.push(trace.circle);
                    velocities.push(trace.v);
                    accelerations.push(trace.av);
                    // push to save trace position for a time! then show!
                }

                if (positions.length > 0) {
                    points
                        .addPointsVertices(positions)
                        .addVelocities(velocities)
                        .addAccelerations(accelerations)
                }

                shell.tracesSeries++;

                // should clear old vertices
                // const prevOldVertices = oldVertices;
                // const prevOldColors = oldColors;

                if (shell && shell.tracesSeries <= shell.maxTracesSeries) {
                    traces.addVertices(
                        points.vertices
                    ).addColors(
                        points.colors
                    );

                    // oldVertices = new Float32Array(points.vertices.length + oldVertices.length);
                    // oldVertices.set(prevOldVertices);
                    // oldVertices.set(points.vertices, prevOldVertices.length);

                    // oldColors = new Float32Array(points.colors.length + oldColors.length);
                    // oldColors.set(prevOldColors);
                    // oldColors.set(points.colors, prevOldColors.length);
                    points.move();
                } else {
                    // firework.points = null;

                    // shell = null;
                    // oldVertices = new Float32Array();
                    // oldColors = new Float32Array();
                }
                // console.log(oldVertices.length / 2);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, traces.colors, gl.STATIC_DRAW);


                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, traces.vertices, gl.STATIC_DRAW);
                gl.drawArrays(gl.POINTS, 0, (traces.vertices.length) / 2);
            }

            shadersCount.innerText = `${numOfHeads}, ${numOfTraces}`; 


            prevTime = time
            requestAnimationFrame(frame);
        }
    
        frame()

        // setInterval(() => {
        //     frame();
        // }, 10);

        const canvasCoordsToWebGL = (x, y) => {

            return [
                x,
                canvas.height - y,
            ]
        }

        canvas.onclick = (e) => {
            const [x, y] = canvasCoordsToWebGL(e.offsetX, e.offsetY);

            const step = Math.PI * 2 / 30;

            const vMax = 10;

            fireworks.push(
                new Shell(x, y, Math.random(), Math.random(), Math.random(), 1)
            );
        }


    </script>
</body>
</html>