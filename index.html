<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webgl</title>
</head>
<body>
    <canvas id="canvas" style="border: solid"> </canvas>
    <div>
        <span>
            FPS: <span id="fps"></span>
        </span>
        <span>
            Amount of vertex: <span id="shadersCount"></span>
        </span>
    </div>
    <script>
        const options = {}

        /**
         * @deprecated 
         */
        class Circles {
            /**
             * @param {WebGLRenderingContext} gl
             * @param {Array.< Array.<{x: Number, y: Number, r: Number, vx: Number, vy: Number}> >} circlesParams
             */
            constructor(gl, trianglesInsideCircle = 16) {
                this.gl = gl;
                this.trianglesInsideCircle = trianglesInsideCircle;

                this.vertexComponents = 2; // [x, y]
                this.triangleBasePoints = 2; // [x1, y1] [x2, y2] 2 triangle vertices connected to 1 point [x0, y0]

                // points for 1 circle
                this.circlePointQuantity = this.trianglesInsideCircle * this.triangleBasePoints * this.vertexComponents + this.vertexComponents;

                this.vertices = new Float32Array(0);
                this.velocities = new Float32Array(0);
                this.accelerations = new Float32Array(0);
            }

            get circlesQuantity() {
                return this.vertices.length / this.circlePointQuantity;
            }

            get circleVerticesQuantity() {
                return this.circlePointQuantity / this.vertexComponents;
            }

            expandArray(length, array) {
                const newArray = new Float32Array(
                    length * this.vertexComponents + array.length
                );

                newArray.set(array);

                return newArray;
            }

            /**
             * @param {Array.< Array.<{avx: Number, avy: Number}> >} params
             */
            addAccelerations(params) {
                const fillFrom = this.accelerations.length;

                this.accelerations = this.expandArray(params.length, this.accelerations);

                for (let i = 0; i < params.length; i++) {
                    const { avx, avy } = params[i];

                    // [x => i*2 + 0]...
                    this.accelerations[i * this.vertexComponents + fillFrom] = avx;
                    // [y => i*2 + 1]...
                    this.accelerations[i * this.vertexComponents + 1 + fillFrom] = avy;
                }

                console.log(this.accelerations);

                return this;
            }

            

            /** 
             * @param {Array.< Array.<{vx: Number, vy: Number >} params
             */
            addVelocities(params) {
                const fillFrom = this.velocities.length;

                this.velocities = this.expandArray(params.length, this.velocities);

                for (let i = 0; i < params.length; i++) {
                    const { vx, vy } = params[i];

                    // [x => i*2 + 0]...
                    this.velocities[i * this.vertexComponents + fillFrom] = vx;
                    // [y => i*2 + 1]...
                    this.velocities[i * this.vertexComponents + 1 + fillFrom] = vy;
                }

                console.log(this.velocities);

                return this;
            }

             /**
             *  @param {Array.<{x: Number, y: Number, r: Number >} params
             */
            addCirclesVertices(params) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(params.length, this.vertices);

                const { 
                    triangleBasePoints, 
                    trianglesInsideCircle, 
                    vertexComponents 
                } = this; // 2 triangle vertices connected to 1 point
                
                const step = (Math.PI * 2) / trianglesInsideCircle;

                for (let circleI = 0; circleI < params.length; circleI++) {
                    const circleOffset = circleI * this.circlePointQuantity + fillFrom;
                    const { x, y, r } = params[circleI];
                    
                    // center point (hub) [x0, y0], the point in which all triangle's bases connected
                    this.vertices[circleOffset] = x;
                    this.vertices[circleOffset + 1] = y;

                    // connected points [x1, y1, x2, y2, ...] to hub
                    for (let i = 0; i < Math.PI * 2; i += step) { // TODO:change this for by maxCount points
                        // ( (i / step) - index of current triangle = 
                        // ==> + step/2 ) - adding small number to prevent floating point errors 
                        // ==> * (triangleBasePoints * vertexComponents) - for each iter. skip triangle = ,[x1, y1] [x2, y2],
                        // ==> + vertexComponents - skip first hub point
                        // ==> + circleOffset - skip existing circles

                        const point2Index = Math.floor((i / step) + step/2) * (triangleBasePoints * vertexComponents) + vertexComponents + circleOffset;
                        const point3Index = point2Index + vertexComponents;
               
                        this.vertices[point2Index] = x + Math.cos(i) * r;
                        this.vertices[point2Index + 1] = y + Math.sin(i) * r;

                        this.vertices[point3Index] = x + Math.cos(i + step) * r;
                        this.vertices[point3Index + 1] = y + Math.sin(i + step) * r;
                    }
                }

                console.log(this.vertices)

                return this;
            }

            move() {
                for (let i = 0; i < this.velocities.length; i+= this.vertexComponents) {
                    const vx = this.velocities[i];
                    const vy = this.velocities[i + 1];

                    const avx = this.accelerations[i];
                    const avy = this.accelerations[i + 1];

                    this.velocities[i] += avx;
                    this.velocities[i + 1] += avy;

                    // this.velocities[i] /= 1.1;
                    // this.velocities[i + 1] /= 1.1;

                    // if (Math.random() > 0.9) {
                    //     this.velocities[i] /= 1.1;
                    //     this.velocities[i + 1] /= 1.1;
                    // }

                    // velocity corresponds for multiple points (circle)
                    // i / this.vertexComponents - index of current velocity vector
                    // * this.circlePointQuantity - skip points for each circle
                    const startPointIndex = (i / this.vertexComponents) * this.circlePointQuantity; // center point (hub)

                    // iterate through each circle [fromCircle -> x0, y0, x1, y1, x2, y2, ... toCircle]
                    for (let j = 0; j < this.circlePointQuantity; j+= this.vertexComponents) {
                        this.vertices[j + startPointIndex] += vx;
                        this.vertices[j + startPointIndex + 1] += vy;
                    }

                    // if (this.vertices[startPointIndex] + r + vx > canvas.width || this.vertices[startPointIndex] - r + vx < 0) {
                       
                    // }

                    // if (this.vertices[startPointIndex + 1] + r + vy > canvas.height || this.vertices[startPointIndex + 1] - r + vy < 0) {
                    
                    // }
                }
            }

            // removeLastCircle() {
            //     this.circlesParams.pop();
            //     this.init();
            // }

            draw() {
                for (let offset = 0; offset < this.vertices.length; offset += this.circleVerticesQuantity) {
                    this.gl.drawArrays(gl.TRIANGLE_FAN, offset, this.circleVerticesQuantity);
                }
            }
        }

        // class StaticPoints {}

        class Points {
            static VERTEX_COMPONENTS = 2; // [x, y]
            static COLOR_COMPONENTS = 4; // [r, g, b, a]
            static X_INDEX = 0;
            static Y_INDEX = 1;
            static R_INDEX = 0;
            static G_INDEX = 1;
            static B_INDEX = 2;
            static A_INDEX = 3;
            constructor() {
                this.vertices = new Float32Array(0);
                this.colors = new Float32Array(0);
            }

            *[Symbol.iterator]() {
                for (let i = 0; i < this.vertices.length / Points.VERTEX_COMPONENTS; i++) {
                    const positionFromIndex = i * Points.VERTEX_COMPONENTS;
                    const colorFromIndex = i * Points.COLOR_COMPONENTS;

                    yield {
                        x: this.vertices[positionFromIndex],
                        y: this.vertices[positionFromIndex + 1],
                        r: this.colors[colorFromIndex],
                        g: this.colors[colorFromIndex + 1],
                        b: this.colors[colorFromIndex + 2],
                        a: this.colors[colorFromIndex + 3],
                        index: i,
                    }
                }
            }

            get quantity() {
                return this.vertices.length / Points.VERTEX_COMPONENTS;
            }

            expandArray(length, array, vc = Points.VERTEX_COMPONENTS) {
                const newArray = new Float32Array(
                    length * vc + array.length
                );

                newArray.set(array);

                return newArray;
            }

            addVertices(vertices) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(vertices.length, this.vertices, 1);

                for (let i = 0; i < vertices.length; i++) {
                    this.vertices[i + fillFrom] = vertices[i];
                }

                return this;
            }

            addColors(colors) {
                const fillFrom = this.colors.length;

                this.colors = this.expandArray(colors.length, this.colors, 1);

                for (let i = 0; i < colors.length; i++) {
                    this.colors[i + fillFrom] = colors[i];
                }

                return this;
            }
        }

        class Particles extends Points {
            constructor() {
                super();
                this.velocities = new Float32Array(0);
                this.accelerations = new Float32Array(0);

                this.vReduction = 1.1;
                this.aReduction = 1.1;
            }
            

            /**
             * @param {Array.<{
             *  x: Number,
             *  y: Number,
             *  vx: Number,
             *  vy: Number,
             *  avx: Number,
             *  avy: Number,
             *  r: Number,
             *  g: Number,
             *  b: Number,
             *  a: Number,
             * }>} params
             */
            addPoints(params) {
                const fillFrom = this.vertices.length;

                this.vertices = this.expandArray(params.length, this.vertices);
                this.velocities = this.expandArray(params.length, this.velocities);
                this.accelerations = this.expandArray(params.length, this.accelerations);
                this.colors = this.expandArray(params.length, this.colors, Points.COLOR_COMPONENTS);

                for (let i = 0; i < params.length; i++) {
                    const { 
                        x, y, 
                        vx, vy, 
                        avx, avy, 
                        r, g, b, a 
                    } = params[i];

                    // [x => i*2 + 0]...
                    this.vertices[i * Points.VERTEX_COMPONENTS + fillFrom] = x;
                    // [y => i*2 + 1]...
                    this.vertices[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = y;

                    // velocities
                    this.velocities[i * Points.VERTEX_COMPONENTS + fillFrom] = vx;
                    this.velocities[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = vy;

                    // accelerations
                    this.accelerations[i * Points.VERTEX_COMPONENTS + fillFrom] = avx;
                    this.accelerations[i * Points.VERTEX_COMPONENTS + 1 + fillFrom] = avy;

                    // colors
                    this.colors[i * Points.COLOR_COMPONENTS + fillFrom] = r;
                    this.colors[i * Points.COLOR_COMPONENTS + 1 + fillFrom] = g;
                    this.colors[i * Points.COLOR_COMPONENTS + 2 + fillFrom] = b;   
                    this.colors[i * Points.COLOR_COMPONENTS + 3 + fillFrom] = a;
                }

                return this;
            }

            move() {
                for (let i = 0; i < this.velocities.length; i+= Points.VERTEX_COMPONENTS) {
                    const vx = this.velocities[i];
                    const vy = this.velocities[i + 1];
                    const avx = this.accelerations[i];
                    const avy = this.accelerations[i + 1];

                    //v resistance
                    this.velocities[i] /= this.vReduction;
                    this.velocities[i + 1] /= this.vReduction;

                    // a resistance
                    this.accelerations[i] /= this.aReduction;
                    this.accelerations[i + 1] /= this.aReduction;

                    this.vertices[i] += vx;
                    this.vertices[i + 1] += vy;

                    this.velocities[i] += avx;  
                    this.velocities[i + 1] += avy;

                    // if (this.vertices[i] + vx > canvas.width || this.vertices[i] + vx < 0) {
                    //     this.velocities[i] *= -1;
                    // }

                    // if (this.vertices[i + 1] + vy > canvas.height || this.vertices[i + 1] + vy < 0) {
                    //     this.velocities[i + 1] *= -1;
                    // }
                }
            }
        }

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas');
        canvas.width = 900;
        canvas.height = 900;
    
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('webgl not supported');
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type); // создание шейдера

            gl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код
            gl.compileShader(shader); 
            // компилируем шейдер

            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {                        // если компиляция прошла успешно - возвращаем шейдер
                return shader;
            }
            
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();

            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.linkProgram(program);

            const success = gl.getProgramParameter(program, gl.LINK_STATUS);

            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const variables = {
            position: 'a_position',
            color: 'a_color',
            canvasSize: 'canvasSize',
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, 
        `
            precision mediump float;

            // атрибут, который будет получать данные из !!буфера
            attribute vec2 ${variables.position};
            attribute vec4 ${variables.color};

            uniform vec2 ${variables.canvasSize};

            varying vec4 v_color;

            vec2 posToClipSpace(vec2 position) {
                return (position / ${variables.canvasSize}) * 2.0 - 1.0;
            }
            
            // все шейдеры имеют функцию main
            void main() {
                v_color = ${variables.color};

                vec2 clipPosition = posToClipSpace(${variables.position});
                gl_PointSize = 2.0;
                // gl_Position - специальная переменная вершинного шейдера,
                // которая отвечает за установку положения
                gl_Position = vec4(clipPosition, 0, 1);
            }
        `
        );
        
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, 
        `
            // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам необходимо её
            precision mediump float;

            varying vec4 v_color;

            void main() {
                // gl_FragColor - специальная переменная фрагментного шейдера.
                // Она отвечает за установку цвета.
                gl_FragColor = v_color;
            }
        `
        );
        
        const program = createProgram(gl, vertexShader, fragmentShader);

        
        gl.useProgram(program);

        
        const locations = {
            // offset: gl.getUniformLocation(program, variables.shapeLocation),
            position: gl.getAttribLocation(program, variables.position),
            color: gl.getAttribLocation(program, variables.color),
            canvasSize: gl.getUniformLocation(program, variables.canvasSize),
        };

        // global variables
        gl.uniform2f(locations.canvasSize, canvas.width, canvas.height);


        // const circles = new Circles(gl, 4);

        // Привязываем буфер положений
        const positionBuffer = gl.createBuffer();
        const colorsBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // передаём в буфер вершины
        // gl.bufferData(gl.ARRAY_BUFFER, circles.vertices, gl.STATIC_DRAW);


        //  buffer -> attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(locations.position);
        gl.vertexAttribPointer(
            locations.position, 
            2, 
            gl.FLOAT, 
            false, 
            2 * Float32Array.BYTES_PER_ELEMENT, 
            0
        );

        gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer)
        gl.enableVertexAttribArray(locations.color)
        gl.vertexAttribPointer(
            locations.color, 
            4, 
            gl.FLOAT, 
            false, 
            4 * Float32Array.BYTES_PER_ELEMENT, 
            0
        )


        /*
            
            // Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
            const size = 2;          // 2 компоненты на итерацию
            const type = gl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой
            const normalize = false; 
            const stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
            const offset = 0;        // начинать с начала буфера
            gl.vertexAttribPointer(
                // index: which attr to use  
                locations.position, 
                // size: how many components in that attr 
                size, 
                // type: what is the type stored in the GPU buffer for this attr 
                type, 
                // normalize: determines how to convert ints to float (convert from 0-255 to 0-1) 
                normalize, 
                // stride: how many bytes to move forward to get the same attr for the next vertex 
                2 * Float32Array.BYTES_PER_ELEMENT, // if 0 = size * sizeof(type)
                // offset: how many bytes skip when reading attrs 
                offset
            );

        */



        gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // gl.enable(gl.BLEND);
        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE);

        /**
         * @type {Array.<Shell>}
         */
        const fireworks = [];
        const delayedFireworks = [];

        class Shell {
            /**
             * @param {{x: Number, y: Number, r: Number, g: Number, b: Number, a: Number}} positionColor
             * @param {{
             * count: Number, 
             * vMax: Number,
             * maxTracesSeries: Number,
             * vReduction: Number,
             * aReduction: Number,
             * headExplosionAfterSeries: Number,
             * skipFramesBeforeExplosion: Number,
             * startDisapearAfterFrames: Number,
             * }} params
             */

            constructor(positionColor, params) {
                this.x = positionColor.x;
                this.y = positionColor.y;
                
                this.r = positionColor.r;
                this.g = positionColor.g;
                this.b = positionColor.b;
                this.a = positionColor.a;

                this.count = params.count;
                this.vMax = params.vMax;

                
                this.maxTracesSeries = params.maxTracesSeries;
                this._tracesSeries = 0;

                this.traceSeriesGenerator = this.generateHeads();

                this.traces = new Points(gl); // static points
                this.heads = new Particles(gl); 

                this.heads.aReduction = params.aReduction;
                this.heads.vReduction = params.vReduction;

                this.headExplosionAfterSeries = params.headExplosionAfterSeries;
                this.skipFramesBeforeExplosion = params.skipFramesBeforeExplosion;
                this.startDisapearAfterFrames = params.startDisapearAfterFrames;

                this.state = {
                    headExplodeTimes: 0,
                    visibleTracesQuantity: this.count * this.maxTracesSeries,
                };
            }
            
            *generateHeads() {
                const { vMax, x, y, r, g, b, a } = this;

                for (let i = 0; i < this.count; i += 1) {
                    const angle = Math.PI * 2 * i / this.count;

                    yield { 
                        x: x + Math.cos(angle),
                        y: y + Math.sin(angle),
                        vx:  Math.cos(angle) * vMax * Math.random(),
                        vy:  Math.sin(angle) * vMax * Math.random(),
                        avx: 0,
                        avy: -0.04,
                        r, g, b, a
                    };
                }
            }

            frame() {
                if (this.skipFramesBeforeExplosion > 0) {
                    this.skipFramesBeforeExplosion--;
                    return;
                }

                this._tracesSeries++;

                const { heads, traces } = this;
                const tracesSerie = [];

                for (const trace of this.traceSeriesGenerator) {
                    tracesSerie.push(trace);
                }

                if (tracesSerie.length > 0) {
                    heads.addPoints(tracesSerie);
                }


                heads.move();

                if (this._tracesSeries <= this.maxTracesSeries) {
                    this.addTraces();
                } else {
                    this.onTraceEnd();
                    // firework.points = null;
                    // traces.vertices = new Float32Array();
                    // shell = null;
                    // oldVertices = new Float32Array();
                    // oldColors = new Float32Array();
                }

                if (this._tracesSeries >= this.headExplosionAfterSeries && this.state.headExplodeTimes < 1) {
                    this.state.headExplodeTimes += 1;

                    this.explodeHeads();
                }

                if (this._tracesSeries >= this.startDisapearAfterFrames && this.state.visibleTracesQuantity > 0) {
                    this.disapearTraces(0);
                }

                // if (this.state.visibleTracesQuantity <= 0) {
                //     this.heads = null;
                //     this.traces = null;
                //     fireworks.splice(fireworks.indexOf(this), 1);
                //     console.log('firework removed', fireworks.length)
                // }
            }
            //fix collors
            // add all setings, reductions, etc to shell

            explodeHeads() {
                for (const head of this.heads) {
                    const shell = new Shell(
                        {
                            x: head.x,
                            y: head.y,
                            r: this.r,
                            g: this.g,
                            b: this.b,
                            a: 1,
                        },
                        {
                            skipFramesBeforeExplosion: head.index,
                            count: 4,
                            vMax: 2,
                            maxTracesSeries: 3,
                            aReduction: 1.01,
                            vReduction: 1.1,
                            startDisapearAfterFrames: 10,
                        }
                    )

                    fireworks.push(shell);
                }
            }

            /**
             * @param {Number} affrectedCount - the number of elements affected by the reductionCoef
             * @param {Number} reductionCoef - the coefficient by which the alpha channel will be reduced
             * @returns {number} - the number of colors which alpha channel more than 0
             */
            randomDisappearance(reductionCoef, affrectedCount) {
                const randomIndexes = new Set();

                for (let i = 0; i < affrectedCount; i++) {
                    randomIndexes.add(Math.floor(Math.random() * this.state.visibleTracesQuantity));
                }

                let visibleQuantity = 0;

                for (const trace of this.traces) {
                    const { a, index } = trace;
                    
                    if (a > 0) {
                        if (randomIndexes.has(visibleQuantity)) {
                            for (let i = affrectedCount; i > 0; i--) {
                                this.traces.colors[index * Points.COLOR_COMPONENTS + Points.A_INDEX] -= reductionCoef;
                            }

                        }
                            visibleQuantity += 1;
                        }
                    }  

                    return visibleQuantity;
            }

            fromFirstToLastDisappearance(reductionCoef, affrectedCount) {
                let visibleQuantity = 0;

                for (const trace of this.traces) {
                    const { a, index } = trace;
                    
                    if (a > 0) {
                        if (visibleQuantity < affrectedCount) {
                            this.traces.colors[index * Points.COLOR_COMPONENTS + Points.A_INDEX] -= reductionCoef;
                        }
                            visibleQuantity += 1;
                        }
                }  

                return visibleQuantity;
            }

            disapearTraces(type) {
                if (type === 0) {
                    this.state.visibleTracesQuantity = this.randomDisappearance(0.01, this.count);
                }

                if (type === 1) {
                    this.state.visibleTracesQuantity = this.fromFirstToLastDisappearance(1, this.count);
                }

            }

            addTraces() {
                this.traces.addVertices(
                    this.heads.vertices
                ).addColors(
                    this.heads.colors
                );
            }

            onTraceEnd() {

            }
        }

    
        // let oldVertices = new Float32Array();
        // let oldColors = new Float32Array();
        let prevTime = 0;


        const frame = (time) => {
            if (Math.trunc(time) % 4 === 0) {
                fps.innerText = (1000 / (time - prevTime)).toFixed(2);
            }

            let numOfHeads = 0;
            let numOfTraces = 0;

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            // gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
            gl.clearColor(1, 1, 1, 1);

            
            for (let i = 0; i < fireworks.length; i++) {
                const shell = fireworks[i];

                const { heads, traces } = shell;

                numOfHeads += heads.quantity;
                numOfTraces += traces.quantity;

                shell.frame();

                                
                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, traces.colors, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, traces.vertices, gl.STATIC_DRAW);
                
                gl.drawArrays(gl.POINTS, 0, traces.quantity);

                gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, heads.colors, gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
                gl.bufferData(gl.ARRAY_BUFFER, heads.vertices, gl.STATIC_DRAW);
                
                gl.drawArrays(gl.POINTS, 0, heads.quantity);
            }


            // delayedFireworks.forEach((f) => {
            //     if (f.skipFrames === 0 && f.shell) {
            //         fireworks.push(f.shell);
            //         f.shell = null;
            //     } else {
            //         f.skipFrames--;
            //     }
            // })

            shadersCount.innerText = `${numOfHeads}, ${numOfTraces}`; 


            prevTime = time
            requestAnimationFrame(frame);
        }
    
        frame()

        // setInterval(() => {
        //     frame();
        // }, 1000);

        const canvasCoordsToWebGL = (x, y) => {

            return [
                x,
                canvas.height - y,
            ]
        }

        canvas.onclick = (e) => {
            const [x, y] = canvasCoordsToWebGL(e.offsetX, e.offsetY);

            const step = Math.PI * 2 / 30;

            fireworks.push(
                new Shell({
                    x, 
                    y,
                    r: 1,
                    g: 0,
                    b: 0,
                    a: 1,
                }, {
                    count: 40,
                    vMax: 8,
                    maxTracesSeries: 30,
                    headExplosionAfterSeries: 45,
                    vReduction: 1.05,
                    aReduction: 1.01,
                    startDisapearAfterFrames: 20,
                })
            );
        }


    </script>
</body>
</html>