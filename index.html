<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webgl</title>
</head>
<body>
    <canvas id="canvas" style="border: solid"> </canvas>
    <div>
        <span>
            FPS: <span id="fps"></span>
        </span>
        <span>
            Amount of shaders: <span id="shadersCount"></span>
        </span>
        <input type="checkbox" id="disableBouncingCheckbox">Disable bouncing</input>
    </div>
    <script>
        const options = {
            disableBouncing: false,
        }

        disableBouncingCheckbox.onchange = (e) => {
            options.disableBouncing = e.target.checked;
        }

        class Circles {
            /**
             * @param {WebGLRenderingContext} gl
             * @param {Array.< Array.<{x: Number, y: Number, r: Number, vx: Number, vy: Number}> >} circlesParams
             */
            constructor(gl, trianglesInsideCircle = 16) {
                this.gl = gl;
                this.trianglesInsideCircle = trianglesInsideCircle;

                this.vertexComponents = 2; // [x, y]
                this.triangleBasePoints = 2; // [x1, y1] [x2, y2] 2 triangle vertices connected to 1 point [x0, y0]

                // points for 1 circle
                this.circlePointQuantity = this.trianglesInsideCircle * this.triangleBasePoints * this.vertexComponents + this.vertexComponents;

                this.vertices = new Float32Array(0);
                this.velocities = new Float32Array(0);
                this.accelerations = new Float32Array(0);
            }

            get circlesQuantity() {
                return this.vertices.length / this.circlePointQuantity;
            }

            get circleVerticesQuantity() {
                return this.circlePointQuantity / this.vertexComponents;
            }

            expandVerticesArray(verticesLength) {
                const newVertices = new Float32Array(
                    verticesLength * this.circlePointQuantity + this.vertices.length
                );

                newVertices.set(this.vertices);
                
                this.vertices = newVertices;
            }

            expandVelocitiesArray(circlesLength) {
                const newVelocities = new Float32Array(
                    circlesLength * this.vertexComponents + this.velocities.length
                );

                newVelocities.set(this.velocities);

                this.velocities = newVelocities;
            }

            expandAccelerationsArray(circlesLength) {
                const newAccelerations = new Float32Array(
                    circlesLength * this.vertexComponents + this.accelerations.length
                );

                newAccelerations.set(this.accelerations);

                this.accelerations = newAccelerations;
            }

            /**
             * @param {Array.< Array.<{avx: Number, avy: Number}> >} params
             */
            addAccelerations(params) {
                const fillFrom = this.accelerations.length;

                this.expandAccelerationsArray(params.length);

                for (let i = 0; i < params.length; i++) {
                    const { avx, avy } = params[i];

                    // [x => i*2 + 0]...
                    this.accelerations[i * this.vertexComponents + fillFrom] = avx;
                    // [y => i*2 + 1]...
                    this.accelerations[i * this.vertexComponents + 1 + fillFrom] = avy;
                }

                console.log(this.accelerations);

                return this;
            }

            

            /** 
             * @param {Array.< Array.<{vx: Number, vy: Number >} params
             */
            addVelocities(params) {
                const fillFrom = this.velocities.length;

                this.expandVelocitiesArray(params.length);

                for (let i = 0; i < params.length; i++) {
                    const { vx, vy } = params[i];

                    // [x => i*2 + 0]...
                    this.velocities[i * this.vertexComponents + fillFrom] = vx;
                    // [y => i*2 + 1]...
                    this.velocities[i * this.vertexComponents + 1 + fillFrom] = vy;
                }

                console.log(this.velocities);

                return this;
            }

             /**
             *  @param {Array.<{x: Number, y: Number, r: Number >} params
             */
            addCirclesVertices(params) {
                const fillFrom = this.vertices.length;

                this.expandVerticesArray(params.length);

                const { 
                    triangleBasePoints, 
                    trianglesInsideCircle, 
                    vertexComponents 
                } = this; // 2 triangle vertices connected to 1 point
                
                const step = (Math.PI * 2) / trianglesInsideCircle;

                for (let circleI = 0; circleI < params.length; circleI++) {
                    const circleOffset = circleI * this.circlePointQuantity + fillFrom;
                    const { x, y, r } = params[circleI];
                    
                    // center point (hub) [x0, y0], the point in which all triangle's bases connected
                    this.vertices[circleOffset] = x;
                    this.vertices[circleOffset + 1] = y;

                    // connected points [x1, y1, x2, y2, ...] to hub
                    for (let i = 0; i < Math.PI * 2; i += step) {
                        // ( (i / step) - index of current triangle = 
                        // ==> + step/2 ) - adding small number to prevent floating point errors 
                        // ==> * (triangleBasePoints * vertexComponents) - for each iter. skip triangle = ,[x1, y1] [x2, y2],
                        // ==> + vertexComponents - skip first hub point
                        // ==> + circleOffset - skip existing circles

                        const point2Index = Math.floor((i / step) + step/2) * (triangleBasePoints * vertexComponents) + vertexComponents + circleOffset;
                        const point3Index = point2Index + vertexComponents;
               
                        this.vertices[point2Index] = x + Math.cos(i) * r;
                        this.vertices[point2Index + 1] = y + Math.sin(i) * r;

                        this.vertices[point3Index] = x + Math.cos(i + step) * r;
                        this.vertices[point3Index + 1] = y + Math.sin(i + step) * r;
                    }
                }

                console.log(this.vertices)

                return this;
            }

            move() {
                for (let i = 0; i < this.velocities.length; i+= this.vertexComponents) {
                    const vx = this.velocities[i];
                    const vy = this.velocities[i + 1];

                    const avx = this.accelerations[i];
                    const avy = this.accelerations[i + 1];

                    this.velocities[i] += avx;
                    this.velocities[i + 1] += avy;
                    

                    // velocity corresponds for multiple points (circle)
                    const startPointIndex = (i / this.vertexComponents) * this.circlePointQuantity; // center point (hub)

                    // iterate through each circle [fromCircle -> x0, y0, x1, y1, x2, y2, ... toCircle]
                    for (let j = 0; j < this.circlePointQuantity; j+= this.vertexComponents) {
                        this.vertices[j + startPointIndex] += vx;
                        this.vertices[j + startPointIndex + 1] += vy;
                    }

                    // bouncing
                    const r = 10; // tempRadius should be calculated from circle points / or predefined
                    // collision detection
                    for (let j = 0; j < this.velocities.length; j+= this.vertexComponents) {
                        if (j === i) {
                            continue;
                        }

                        if (options.disableBouncing) {
                            continue;
                        }

                        
                        const ball1X = this.vertices[startPointIndex];
                        const ball1Y = this.vertices[startPointIndex + 1];

                        const ball1Vx = this.velocities[i];
                        const ball1Vy = this.velocities[i+ 1];

                        const ball2XIndex = (j / this.vertexComponents) * this.circlePointQuantity;
                        const ball2YIndex = ball2XIndex + 1;
                        const ball2X = this.vertices[ball2XIndex];
                        const ball2Y = this.vertices[ball2YIndex];

                        const ball2Vx = this.velocities[j];
                        const ball2Vy = this.velocities[j + 1];
                     
                        const dx = ball1X - ball2X;
                        const dy = ball1Y - ball2Y;
                      
                        const distance = Math.hypot(dx, dy);
         
                        const mass = 10;

                        if (distance < r * 2 && distance !== 0) {
                            const nx = dx / distance;
                            const ny = dy / distance;

                            const vxRelativeVelocity = ball1Vx - ball2Vx;
                            const vyRelativeVelocity = ball1Vy - ball2Vy;

                            const speed = vxRelativeVelocity * nx + vyRelativeVelocity * ny;

                            if (speed > 0) {
                                continue;
                            }

                            const p = 2 * speed / (mass * 2);

                            this.velocities[i] -= p * nx;
                            this.velocities[i + 1] -= p * ny;

                            this.velocities[j] += p * nx;
                            this.velocities[j + 1] += p * ny;
                        }

                    }

                    if (this.vertices[startPointIndex] + r + vx > canvas.width || this.vertices[startPointIndex] - r + vx < 0) {
                        this.velocities[i] *= -1;

                        this.velocities[i] /= 2;
                    }

                    if (this.vertices[startPointIndex + 1] + r + vy > canvas.height || this.vertices[startPointIndex + 1] - r + vy < 0) {
                        this.velocities[i + 1] *= -1;

                        this.velocities[i + 1] /= 2;
                    }
                }
            }

            // removeLastCircle() {
            //     this.circlesParams.pop();
            //     this.init();
            // }

            draw() {
                for (let offset = 0; offset < this.vertices.length; offset += this.circleVerticesQuantity) {
                    this.gl.drawArrays(gl.TRIANGLE_FAN, offset, this.circleVerticesQuantity);
                }
            }
        }

        /** @type {HTMLCanvasElement} */
        const canvas = document.getElementById('canvas');
        canvas.width = 900;
        canvas.height = 900;
    
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('webgl not supported');
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type); // создание шейдера

            gl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код
            gl.compileShader(shader); 
            // компилируем шейдер

            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {                        // если компиляция прошла успешно - возвращаем шейдер
                return shader;
            }
            
            console.log(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();

            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);

            gl.linkProgram(program);

            const success = gl.getProgramParameter(program, gl.LINK_STATUS);

            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }

        const variables = {
            position: 'a_position',
            // shapeLocation: 'u_offset',
            color: 'u_color',
            canvasSize: 'canvasSize',
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, 
        `
            precision mediump float;

            // атрибут, который будет получать данные из !!буфера
            attribute vec2 ${variables.position};

            uniform vec2 ${variables.canvasSize};
            uniform vec2 ${variables.shapeLocation};

            vec2 posToClipSpace(vec2 position) {
                return (position / ${variables.canvasSize}) * 2.0 - 1.0;
            }
            
            // все шейдеры имеют функцию main
            void main() {
                vec2 clipPosition = posToClipSpace(${variables.position});

                // gl_Position - специальная переменная вершинного шейдера,
                // которая отвечает за установку положения
                gl_Position = vec4(clipPosition, 0, 1);
            }
        `
        );
        
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, 
        `
            // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам необходимо её
            precision mediump float;
            uniform vec3 ${variables.color};

            void main() {
                // gl_FragColor - специальная переменная фрагментного шейдера.
                // Она отвечает за установку цвета.
                gl_FragColor = vec4(${variables.color}, 1);
            }
        `
        );
        
        const program = createProgram(gl, vertexShader, fragmentShader);

        
        gl.useProgram(program);


        // gl.clearColor(0, 0, 0, 0);
        // gl.clear(gl.COLOR_BUFFER_BIT);

        
        
        const locations = {
            // offset: gl.getUniformLocation(program, variables.shapeLocation),
            color: gl.getUniformLocation(program, variables.color),
            position: gl.getAttribLocation(program, variables.position),
            canvasSize: gl.getUniformLocation(program, variables.canvasSize),
        };

        // global variables
        gl.uniform2f(locations.canvasSize, canvas.width, canvas.height);
        gl.uniform3f(locations.color, Math.random(), Math.random(), Math.random());


        const circles = new Circles(gl, 16)
            // .addCirclesVertices([
            //     {
            //         x: 300,
            //         y: 380,
            //         r: 50, 
            //     },
            //     {
            //         x: 600,
            //         y: 400,
            //         r: 50,
            //     }
            // ])
            // .addVelocities([
            //     {
            //         vx: 10,
            //         vy: 0,
            //     },
            //     {
            //         vx: 0,
            //         vy: 0,
            //     }
            // ])
            // .addAccelerations([
            //     {
            //         avx: 0,
            //         avy: 0,
            //     },
            //     {
            //         avx: 0,
            //         avy: 0,
            //     }
            // ]);
  

        // Привязываем буфер положений
        const positionBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // передаём в буфер вершины
        // gl.bufferData(gl.ARRAY_BUFFER, circles.vertices, gl.STATIC_DRAW);


        //  buffer -> attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(locations.position);
        gl.vertexAttribPointer(
            locations.position, 
            2, 
            gl.FLOAT, 
            false, 
            2 * Float32Array.BYTES_PER_ELEMENT, 
            0
        );


        /*
            
            // Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)
            const size = 2;          // 2 компоненты на итерацию
            const type = gl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой
            const normalize = false; 
            const stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения
            const offset = 0;        // начинать с начала буфера
            gl.vertexAttribPointer(
                // index: which attr to use  
                locations.position, 
                // size: how many components in that attr 
                size, 
                // type: what is the type stored in the GPU buffer for this attr 
                type, 
                // normalize: determines how to convert ints to float (convert from 0-255 to 0-1) 
                normalize, 
                // stride: how many bytes to move forward to get the same attr for the next vertex 
                2 * Float32Array.BYTES_PER_ELEMENT, // if 0 = size * sizeof(type)
                // offset: how many bytes skip when reading attrs 
                offset
            );

        */

        gl.clearColor(5 / 255, 25 / 255, 55 / 255, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        circles.draw();

        let prefMs = 0;

        const frame = (time) => {
            if (Math.trunc(time) % 4 === 0) {
                fps.innerText = (1000 / (time - prefMs)).toFixed(2);
            }

            shadersCount.innerText = circles.vertices.length / 2;

            gl.clearColor(5 / 255, 25 / 255, 55 / 255, 0.99);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


            circles.move();

            gl.bufferData(gl.ARRAY_BUFFER, circles.vertices, gl.STATIC_DRAW);

            circles.draw();

            prefMs = time
            requestAnimationFrame(frame);
        }
        frame()

        // setInterval(() => {
        //     frame();
        // }, 1000);

        const canvasCoordsToWebGL = (x, y) => {

            return [
                x,
                canvas.height - y,
            ]
        }

        canvas.onclick = (e) => {
            const [x, y] = canvasCoordsToWebGL(e.offsetX, e.offsetY);

            const velocities = [];

            const step = Math.PI * 2 / 300;

            const v = 10;

            for (let i = 0; i < Math.PI * 2; i += step) {
                const vx = Math.cos(i) * v;
                const vy = Math.sin(i) * v;

                velocities.push({
                    vx,
                    vy,
                })
         
            }

            // let positions = Array(velocities.length).fill(0).map(() => {
            //     const r = Math.random() * 5;

            //     return {
            //         x,
            //         y,
            //         r: 4,
            //     }
            // });
            // add trace
            // velocities.forEach((pos, i) => {
            //     positions.push({
            //         x: positions[i/3 | 0].x + pos.x * 100,
            //         y: positions[i/3 | 0].y + pos.y * 100,
            //         r: 4,
            //     })
            // })

            const positions = [];

            for (let i = 0; i < velocities.length; i++) {
                    positions.push({
                        x: x + Math.cos(i * step) * 100 ,
                        y: y + Math.sin(i * step) * 100,
                        r: 10,
                    })
              
            }

            circles  
                .addCirclesVertices(positions)
                .addVelocities(velocities)
                .addAccelerations(Array(velocities.length).fill(0).map(() => ({
                    avx: 0,
                    avy: 0,
                })))
        }


        // gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, positionBuffer);
        // gl.drawElements(
        //     gl.TRIANGLE_FAN,
        //     17,
        //     gl.UNSIGNED_SHORT,
        //     0
        // );
    </script>
</body>
</html>